{"version":3,"file":"repeat.js","sourceRoot":"","sources":["../src/directives/repeat.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\nimport {DirectiveFn} from '../lib/directive.js';\nimport {createMarker, directive, NodePart, Part, removeNodes, reparentNodes} from '../lit-html.js';\n\nexport type KeyFn<T> = (item: T, index: number) => any;\nexport type ItemTemplate<T> = (item: T, index: number) => any;\n\n// Helper functions for manipulating parts\n// TODO(kschaaf): Refactor into Part API?\nconst createAndInsertPart =\n    (containerPart: NodePart, beforePart?: NodePart): NodePart => {\n      const container = containerPart.startNode.parentNode as Node;\n      const beforeNode = beforePart === undefined ? containerPart.endNode :\n                                                    beforePart.startNode;\n      const startNode = container.insertBefore(createMarker(), beforeNode);\n      container.insertBefore(createMarker(), beforeNode);\n      const newPart = new NodePart(containerPart.options);\n      newPart.insertAfterNode(startNode);\n      return newPart;\n    };\n\nconst updatePart = (part: NodePart, value: unknown) => {\n  part.setValue(value);\n  part.commit();\n  return part;\n};\n\nconst insertPartBefore =\n    (containerPart: NodePart, part: NodePart, ref?: NodePart) => {\n      const container = containerPart.startNode.parentNode as Node;\n      const beforeNode = ref ? ref.startNode : containerPart.endNode;\n      const endNode = part.endNode.nextSibling;\n      if (endNode !== beforeNode) {\n        reparentNodes(container, part.startNode, endNode, beforeNode);\n      }\n    };\n\nconst removePart = (part: NodePart) => {\n  removeNodes(\n      part.startNode.parentNode!, part.startNode, part.endNode.nextSibling);\n};\n\n// Helper for generating a map of array item to its index over a subset\n// of an array (used to lazily generate `newKeyToIndexMap` and\n// `oldKeyToIndexMap`)\nconst generateMap = (list: unknown[], start: number, end: number) => {\n  const map = new Map();\n  for (let i = start; i <= end; i++) {\n    map.set(list[i], i);\n  }\n  return map;\n};\n\n// Stores previous ordered list of parts and map of key to index\nconst partListCache = new WeakMap<NodePart, (NodePart | null)[]>();\nconst keyListCache = new WeakMap<NodePart, unknown[]>();\n\n/**\n * A directive that repeats a series of values (usually `TemplateResults`)\n * generated from an iterable, and updates those items efficiently when the\n * iterable changes based on user-provided `keys` associated with each item.\n *\n * Note that if a `keyFn` is provided, strict key-to-DOM mapping is maintained,\n * meaning previous DOM for a given key is moved into the new position if\n * needed, and DOM will never be reused with values for different keys (new DOM\n * will always be created for new keys). This is generally the most efficient\n * way to use `repeat` since it performs minimum unnecessary work for insertions\n * amd removals.\n *\n * IMPORTANT: If providing a `keyFn`, keys *must* be unique for all items in a\n * given call to `repeat`. The behavior when two or more items have the same key\n * is undefined.\n *\n * If no `keyFn` is provided, this directive will perform similar to mapping\n * items to values, and DOM will be reused against potentially different items.\n */\nexport const repeat = directive(\n    <T>(items: Iterable<T>,\n        keyFnOrTemplate: KeyFn<T>|ItemTemplate<T>,\n        template?: ItemTemplate<T>): DirectiveFn => {\n      let keyFn: KeyFn<T>;\n      if (template === undefined) {\n        template = keyFnOrTemplate;\n      } else if (keyFnOrTemplate !== undefined) {\n        keyFn = keyFnOrTemplate as KeyFn<T>;\n      }\n\n      return (containerPart: Part): void => {\n        if (!(containerPart instanceof NodePart)) {\n          throw new Error('repeat can only be used in text bindings');\n        }\n        // Old part & key lists are retrieved from the last update (associated\n        // with the part for this instance of the directive)\n        const oldParts = partListCache.get(containerPart) || [];\n        const oldKeys = keyListCache.get(containerPart) || [];\n\n        // New part list will be built up as we go (either reused from old parts\n        // or created for new keys in this update). This is saved in the above\n        // cache at the end of the update.\n        const newParts: NodePart[] = [];\n\n        // New value list is eagerly generated from items along with a parallel\n        // array indicating its key.\n        const newValues: unknown[] = [];\n        const newKeys: unknown[] = [];\n        let index = 0;\n        for (const item of items) {\n          newKeys[index] = keyFn ? keyFn(item, index) : index;\n          newValues[index] = template !(item, index);\n          index++;\n        }\n\n        // Maps from key to index for current and previous update; these are\n        // generated lazily only when needed as a performance optimization,\n        // since they are only required for multiple non-contiguous changes in\n        // the list, which are less common.\n        let newKeyToIndexMap!: Map<unknown, number>;\n        let oldKeyToIndexMap!: Map<unknown, number>;\n\n        // Head and tail pointers to old parts and new values\n        let oldHead = 0;\n        let oldTail = oldParts.length - 1;\n        let newHead = 0;\n        let newTail = newValues.length - 1;\n\n        // Overview of O(n) reconciliation algorithm (general approach based on\n        // ideas found in ivi, vue, snabbdom, etc.):\n        //\n        // * We start with the list of old parts and new values (and arrays of\n        //   their respective keys), head/tail pointers into each, and we build\n        //   up the new list of parts by updating (and when needed, moving) old\n        //   parts or creating new ones. The initial scenario might look like\n        //   this (for brevity of the diagrams, the numbers in the array reflect\n        //   keys associated with the old parts or new values, although keys and\n        //   parts/values are actually stored in parallel arrays indexed using\n        //   the same head/tail pointers):\n        //\n        //      oldHead v                 v oldTail\n        //   oldKeys:  [0, 1, 2, 3, 4, 5, 6]\n        //   newParts: [ ,  ,  ,  ,  ,  ,  ]\n        //   newKeys:  [0, 2, 1, 4, 3, 7, 6] <- reflects the user's new item\n        //   order\n        //      newHead ^                 ^ newTail\n        //\n        // * Iterate old & new lists from both sides, updating, swapping, or\n        //   removing parts at the head/tail locations until neither head nor\n        //   tail can move.\n        //\n        // * Example below: keys at head pointers match, so update old part 0\n        // in-\n        //   place (no need to move it) and record part 0 in the `newParts`\n        //   list. The last thing we do is advance the `oldHead` and `newHead`\n        //   pointers (will be reflected in the next diagram).\n        //\n        //      oldHead v                 v oldTail\n        //   oldKeys:  [0, 1, 2, 3, 4, 5, 6]\n        //   newParts: [0,  ,  ,  ,  ,  ,  ] <- heads matched: update 0 and\n        //   newKeys:  [0, 2, 1, 4, 3, 7, 6]    advance both oldHead & newHead\n        //      newHead ^                 ^ newTail\n        //\n        // * Example below: head pointers don't match, but tail pointers do, so\n        //   update part 6 in place (no need to move it), and record part 6 in\n        //   the `newParts` list. Last, advance the `oldTail` and `oldHead`\n        //   pointers.\n        //\n        //         oldHead v              v oldTail\n        //   oldKeys:  [0, 1, 2, 3, 4, 5, 6]\n        //   newParts: [0,  ,  ,  ,  ,  , 6] <- tails matched: update 6 and\n        //   newKeys:  [0, 2, 1, 4, 3, 7, 6]    advance both oldTail & newTail\n        //         newHead ^              ^ newTail\n        //\n        // * If neither head nor tail match; next check if one of the old\n        // head/tail\n        //   items was removed. We first need to generate the reverse map of new\n        //   keys to index (`newKeyToIndexMap`), which is done once lazily as a\n        //   performance optimization, since we only hit this case if multiple\n        //   non-contiguous changes were made. Note that for contiguous removal\n        //   anywhere in the list, the head and tails would advance from either\n        //   end and pass each other before we get to this case and removals\n        //   would be handled in the final while loop without needing to\n        //   generate the map.\n        //\n        // * Example below: The key at `oldTail` was removed (no longer in the\n        //   `newKeyToIndexMap`), so remove that part from the DOM and advance\n        //   just the `oldTail` pointer.\n        //\n        //         oldHead v           v oldTail\n        //   oldKeys:  [0, 1, 2, 3, 4, 5, 6]\n        //   newParts: [0,  ,  ,  ,  ,  , 6] <- 5 not in new map; remove 5 and\n        //   newKeys:  [0, 2, 1, 4, 3, 7, 6]    advance oldTail\n        //         newHead ^           ^ newTail\n        //\n        // * Once head and tail cannot move, any mismatches are due to either\n        // new or\n        //   moved items; if a new key is in the previous \"old key to old index\"\n        //   map, move the old part to the new location, otherwise create and\n        //   insert a new part. Note that when moving an old part we null its\n        //   position in the oldParts array if it lies between the head and tail\n        //   so we know to skip it when the pointers get there.\n        //\n        // * Example below: neither head nor tail match, and neither were\n        // removed;\n        //   so find the `newHead` key in the `oldKeyToIndexMap`, and move that\n        //   old part's DOM into the next head position (before\n        //   `oldParts[oldHead]`). Last, null the part in the `oldPart` array\n        //   since it was somewhere in the remaining oldParts still to be\n        //   scanned (between the head and tail pointers) so that we know to\n        //   skip that old part on future iterations.\n        //\n        //         oldHead v        v oldTail\n        //   oldKeys:  [0, 1, -, 3, 4, 5, 6]\n        //   newParts: [0, 2,  ,  ,  ,  , 6] <- stuck; update & move 2 into\n        //   place newKeys:  [0, 2, 1, 4, 3, 7, 6]    and advance newHead\n        //         newHead ^           ^ newTail\n        //\n        // * Note that for moves/insertions like the one above, a part inserted\n        // at\n        //   the head pointer is inserted before the current\n        //   `oldParts[oldHead]`, and a part inserted at the tail pointer is\n        //   inserted before `newParts[newTail+1]`. The seeming asymmetry lies\n        //   in the fact that new parts are moved into place outside in, so to\n        //   the right of the head pointer are old parts, and to the right of\n        //   the tail pointer are new parts.\n        //\n        // * We always restart back from the top of the algorithm, allowing\n        // matching\n        //   and simple updates in place to continue...\n        //\n        // * Example below: the head pointers once again match, so simply update\n        //   part 1 and record it in the `newParts` array.  Last, advance both\n        //   head pointers.\n        //\n        //         oldHead v        v oldTail\n        //   oldKeys:  [0, 1, -, 3, 4, 5, 6]\n        //   newParts: [0, 2, 1,  ,  ,  , 6] <- heads matched; update 1 and\n        //   newKeys:  [0, 2, 1, 4, 3, 7, 6]    advance both oldHead & newHead\n        //            newHead ^        ^ newTail\n        //\n        // * As mentioned above, items that were moved as a result of being\n        // stuck\n        //   (the final else clause in the code below) are marked with null, so\n        //   we always advance old pointers over these so we're comparing the\n        //   next actual old value on either end.\n        //\n        // * Example below: `oldHead` is null (already placed in newParts), so\n        //   advance `oldHead`.\n        //\n        //            oldHead v     v oldTail\n        //   oldKeys:  [0, 1, -, 3, 4, 5, 6] // old head already used; advance\n        //   newParts: [0, 2, 1,  ,  ,  , 6] // oldHead\n        //   newKeys:  [0, 2, 1, 4, 3, 7, 6]\n        //               newHead ^     ^ newTail\n        //\n        // * Note it's not critical to mark old parts as null when they are\n        // moved\n        //   from head to tail or tail to head, since they will be outside the\n        //   pointer range and never visited again.\n        //\n        // * Example below: Here the old tail key matches the new head key, so\n        //   the part at the `oldTail` position and move its DOM to the new\n        //   head position (before `oldParts[oldHead]`). Last, advance `oldTail`\n        //   and `newHead` pointers.\n        //\n        //               oldHead v  v oldTail\n        //   oldKeys:  [0, 1, -, 3, 4, 5, 6]\n        //   newParts: [0, 2, 1, 4,  ,  , 6] <- old tail matches new head:\n        //   update newKeys:  [0, 2, 1, 4, 3, 7, 6]   & move 4, advance oldTail\n        //   & newHead\n        //               newHead ^     ^ newTail\n        //\n        // * Example below: Old and new head keys match, so update the old head\n        //   part in place, and advance the `oldHead` and `newHead` pointers.\n        //\n        //               oldHead v oldTail\n        //   oldKeys:  [0, 1, -, 3, 4, 5, 6]\n        //   newParts: [0, 2, 1, 4, 3,   ,6] <- heads match: update 3 and\n        //   advance newKeys:  [0, 2, 1, 4, 3, 7, 6]    oldHead & newHead\n        //                  newHead ^  ^ newTail\n        //\n        // * Once the new or old pointers move past each other then all we have\n        //   left is additions (if old list exhausted) or removals (if new list\n        //   exhausted). Those are handled in the final while loops at the end.\n        //\n        // * Example below: `oldHead` exceeded `oldTail`, so we're done with the\n        //   main loop.  Create the remaining part and insert it at the new head\n        //   position, and the update is complete.\n        //\n        //                   (oldHead > oldTail)\n        //   oldKeys:  [0, 1, -, 3, 4, 5, 6]\n        //   newParts: [0, 2, 1, 4, 3, 7 ,6] <- create and insert 7\n        //   newKeys:  [0, 2, 1, 4, 3, 7, 6]\n        //                     newHead ^ newTail\n        //\n        // * Note that the order of the if/else clauses is not important to the\n        //   algorithm, as long as the null checks come first (to ensure we're\n        //   always working on valid old parts) and that the final else clause\n        //   comes last (since that's where the expensive moves occur). The\n        //   order of remaining clauses is is just a simple guess at which cases\n        //   will be most common.\n        //\n        // * TODO(kschaaf) Note, we could calculate the longest increasing\n        //   subsequence (LIS) of old items in new position, and only move those\n        //   not in the LIS set. However that costs O(nlogn) time and adds a bit\n        //   more code, and only helps make rare types of mutations require\n        //   fewer moves. The above handles removes, adds, reversal, swaps, and\n        //   single moves of contiguous items in linear time, in the minimum\n        //   number of moves. As the number of multiple moves where LIS might\n        //   help approaches a random shuffle, the LIS optimization becomes less\n        //   helpful, so it seems not worth the code at this point. Could\n        //   reconsider if a compelling case arises.\n\n        while (oldHead <= oldTail && newHead <= newTail) {\n          if (oldParts[oldHead] === null) {\n            // `null` means old part at head has already been used below; skip\n            oldHead++;\n          } else if (oldParts[oldTail] === null) {\n            // `null` means old part at tail has already been used below; skip\n            oldTail--;\n          } else if (oldKeys[oldHead] === newKeys[newHead]) {\n            // Old head matches new head; update in place\n            newParts[newHead] =\n                updatePart(oldParts[oldHead]!, newValues[newHead]);\n            oldHead++;\n            newHead++;\n          } else if (oldKeys[oldTail] === newKeys[newTail]) {\n            // Old tail matches new tail; update in place\n            newParts[newTail] =\n                updatePart(oldParts[oldTail]!, newValues[newTail]);\n            oldTail--;\n            newTail--;\n          } else if (oldKeys[oldHead] === newKeys[newTail]) {\n            // Old head matches new tail; update and move to new tail\n            newParts[newTail] =\n                updatePart(oldParts[oldHead]!, newValues[newTail]);\n            insertPartBefore(\n                containerPart, oldParts[oldHead]!, newParts[newTail + 1]);\n            oldHead++;\n            newTail--;\n          } else if (oldKeys[oldTail] === newKeys[newHead]) {\n            // Old tail matches new head; update and move to new head\n            newParts[newHead] =\n                updatePart(oldParts[oldTail]!, newValues[newHead]);\n            insertPartBefore(\n                containerPart, oldParts[oldTail]!, oldParts[oldHead]!);\n            oldTail--;\n            newHead++;\n          } else {\n            if (newKeyToIndexMap === undefined) {\n              // Lazily generate key-to-index maps, used for removals & moves\n              // below\n              newKeyToIndexMap = generateMap(newKeys, newHead, newTail);\n              oldKeyToIndexMap = generateMap(oldKeys, oldHead, oldTail);\n            }\n            if (!newKeyToIndexMap.has(oldKeys[oldHead])) {\n              // Old head is no longer in new list; remove\n              removePart(oldParts[oldHead]!);\n              oldHead++;\n            } else if (!newKeyToIndexMap.has(oldKeys[oldTail])) {\n              // Old tail is no longer in new list; remove\n              removePart(oldParts[oldTail]!);\n              oldTail--;\n            } else {\n              // Any mismatches at this point are due to additions or moves; see\n              // if we have an old part we can reuse and move into place\n              const oldIndex = oldKeyToIndexMap.get(newKeys[newHead]);\n              const oldPart =\n                  oldIndex !== undefined ? oldParts[oldIndex] : null;\n              if (oldPart === null) {\n                // No old part for this value; create a new one and insert it\n                const newPart =\n                    createAndInsertPart(containerPart, oldParts[oldHead]!);\n                updatePart(newPart, newValues[newHead]);\n                newParts[newHead] = newPart;\n              } else {\n                // Reuse old part\n                newParts[newHead] = updatePart(oldPart, newValues[newHead]);\n                insertPartBefore(containerPart, oldPart, oldParts[oldHead]!);\n                // This marks the old part as having been used, so that it will\n                // be skipped in the first two checks above\n                oldParts[oldIndex as number] = null;\n              }\n              newHead++;\n            }\n          }\n        }\n        // Add parts for any remaining new values\n        while (newHead <= newTail) {\n          // For all remaining additions, we insert before last new tail,\n          // since old pointers are no longer valid\n          const newPart =\n              createAndInsertPart(containerPart, newParts[newTail + 1]!);\n          updatePart(newPart, newValues[newHead]);\n          newParts[newHead++] = newPart;\n        }\n        // Remove any remaining unused old parts\n        while (oldHead <= oldTail) {\n          const oldPart = oldParts[oldHead++];\n          if (oldPart !== null) {\n            removePart(oldPart);\n          }\n        }\n        // Save order of new parts for next round\n        partListCache.set(containerPart, newParts);\n        keyListCache.set(containerPart, newKeys);\n      };\n    });\n"]}